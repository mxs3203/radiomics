---
title: "Radiomics"
output:
  pdf_document: default
  html_document: default
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
library(readxl)
library(ggrepel)
library(pheatmap)
library(factoextra)
library(cluster)
library(tidyverse)
library(plotly)
library(ggmosaic)
library(ggpubr)
library(ggbiplot)
library(NMF)
suppressMessages(library(survminer))
suppressMessages(library(survplot))
setwd("~/GenomeDK_local/CancerEvolution/phd/Analysis/radiomics/NMF_Radiomics/")

source("~/GenomeDK_local/CancerEvolution/phd/Analysis/cnsignatures/functions.R")
```

# Loading Everything
```{r pressure, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}

indx100 = get(load("~/GenomeDK_local/CancerEvolution/phd/Datasets/TRACERx/Annotations/indx100.RData"))

ith <- read.delim2("~/GenomeDK_local/CancerEvolution/phd/Datasets/TRACERx/Annotations/comb_ith_analysis.20170127.txt", sep = "\t")
ith$SNV_py <- as.numeric(as.character(ith$SNV_py))
ith$SCNA <- as.numeric(as.character(ith$SCNA))
ith$sampleID <- rownames(ith)
ith2 <- read.delim2("~/GenomeDK_local/CancerEvolution/phd/Datasets/TRACERx/Annotations/scna_ith_trx500.20180731.txt")
ith2$FractionTrunk <- as.numeric(as.character(ith2$FractionTrunk))
ith2$Heterogeneous <- as.numeric(as.character(ith2$Heterogeneous))
ith2$Homogeneous <- as.numeric(as.character(ith2$Homogeneous))

clin_ = as.data.frame(get(load(("~/GenomeDK_local/CancerEvolution/phd/Datasets/TRACERx/Clinical/tracerx_clin.20180701.RData"))))
clin_$ID = rownames(clin_)
clin_$Lesion1SizePath = as.numeric(as.character(clin_$Lesion1SizePath))
clin = read_excel("~/Downloads/TRACERx all patients- July 2020 version 2.xlsx")
clin$ID = paste0(substr(clin$Shorter_ID,0,3), "0",substr(clin$Shorter_ID,4, 8))
pyrad = read_excel("~/GenomeDK_local/CancerEvolution/phd/Datasets/TRACERx/Radiomics/Radiomics20200801/PyRadiomics_20200718/wavelet.xlsx")
pyrad$pathology = case_when(
  pyrad$pathhistr_tracerx_lesion1form == "Invasive adenocarcinoma" ~ "Invasive adenocarcinoma",
  pyrad$pathhistr_tracerx_lesion1form == "Squamous cell carcinoma" ~ "Squamous cell carcinoma",
  TRUE ~ "Other"
)
pyrad = pyrad[-is.na(pyrad),]


pyrad = merge(pyrad, clin, by.y = "ID", by.x = "sampleid", all.x = T )
pyrad = merge(pyrad, clin_ %>% select("ID", "Lesion1SizePath"), by.y = "ID", by.x = "sampleid", all.x = T )

phyl_groups = read.delim2("~/GenomeDK_local/CancerEvolution/phd/Datasets/TRACERx/Annotations/phyl_groups.txt")
phyl_groups$sampleid = rownames(phyl_groups)

mutations = read.csv2("~/GenomeDK_local/CancerEvolution/phd/Datasets/TRACERx/haveDriverMuts.csv", sep=",")

oracle= read.csv2("~/GenomeDK_local/CancerEvolution/phd/Datasets/TRACERx/Annotations/2020-12-08TX421_oracle.csv", sep = ",")
oracle$sampleid = paste0(substr(oracle$PatientID, 3,5), "0", substr(oracle$PatientID, 6,8))
oracle$RiskScore <- as.numeric(as.character(oracle$RiskScore))
oracle = oracle %>% 
  dplyr::group_by(sampleid) %>%
  dplyr::summarize(RiskScore = mean(RiskScore, na.rm = T),
            n = n(),
            lows = sum(bin == "Low"),
            highs = sum(bin == "High"),
            bin = ifelse(highs >= lows, "High", "Low"))

extra_info = read.delim2("~/GenomeDK_local/CancerEvolution/phd/Datasets/TRACERx/Annotations/NewITH/20210722_20210531_tracerx_sample_table_primary_421_annotated.tsv")
new_ith = read.delim2("~/GenomeDK_local/CancerEvolution/phd/Datasets/TRACERx/Annotations/NewITH/20210805_Evo_subgroups.tsv")
new_ith$sampleid = paste0(substr(as.character(new_ith$tumour_id), 0, 3),"0", substr(as.character(new_ith$tumour_id), 4, 6))

features = colnames(pyrad)[52:151]

pyrad = pyrad[complete.cases(pyrad[,features]), ]
minMax <- function(x){
  (x - min(x))/(max(x)-min(x))
}


```
# Project Plan
![Project Plan](/Users/au589901/GenomeDK_local/CancerEvolution/phd/Analysis/radiomics/NMF_Radiomics/Radiomics.png)



# What features to take? 
- Not sure to take Zone Entropy or not \

- Run Entropy and Zone Entropy do not follow the same patter on biplot \


```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

features = features[-which(features == "original_shape_MeshVolume")]
features = features[-grepl("firstorder", features )]

#wavelet.LLL
kernel = "wavelet.LLL"
features_of_interest = c(
  paste0(kernel ,"_glcm_JointEntropy"),
  paste0(kernel ,"_glcm_DifferenceEntropy"),
  paste0(kernel ,"_glcm_DifferenceAverage"),
  paste0(kernel ,"_glcm_DifferenceVariance"),
  paste0(kernel ,"_glrlm_LongRunEmphasis"),
  paste0(kernel ,"_gldm_SmallDependenceEmphasis"),
  paste0(kernel ,"_glrlm_RunPercentage"),
  paste0(kernel ,"_glszm_ZoneEntropy"), # the only one pos cor to volume, so we div with volume
  paste0(kernel ,"_glrlm_RunEntropy")
)
pyrad[,features_of_interest] = pyrad[,features_of_interest]
pyrad[,paste0(kernel, "_glrlm_LongRunEmphasis")]= -pyrad[,paste0(kernel, "_glrlm_LongRunEmphasis")]
pyrad[,paste0(kernel, "_glszm_ZoneEntropy")]= pyrad[,paste0(kernel, "_glszm_ZoneEntropy")]/pyrad[,"original_shape_MeshVolume"]

pyrad[,features_of_interest] = apply(pyrad[,features_of_interest], 2, minMax)

pheatmap(cor(pyrad[,features_of_interest]), 
         fontsize = 8)

pc = prcomp(pyrad[,features_of_interest],center = T)
ggbiplot(pc, labels=rownames(pc)) + 
  theme_pubclean()


```


# Important measures to check
- We will compare diameter to volume to ITH \


```{r echo=TRUE, message=FALSE, warning=FALSE, paged.print=FALSE}
pyrad$volume = as.numeric(pyrad$original_shape_MeshVolume)
pyrad$volume_from_pyrad = as.numeric(pyrad$original_shape_MeshVolume)
pyrad$diameter = as.numeric(pyrad$original_shape_Maximum2DDiameterSlice)

```
# how to define radITH
- Do we need to normalize something by volume? \

- Numbers were a bit wierd when divided by volume therefore I did not divide anything with volume \

```{r echo=TRUE, message=FALSE, warning=FALSE, paged.print=FALSE}
# weighted mean 
w = 1-abs(cor(pyrad[,features_of_interest], pyrad[,"volume"]))
pyrad$radITH = apply(pyrad[,features_of_interest],1, function(x){
   weighted.mean(x[features_of_interest], w = w)
})


#pyrad$radITH = rowMeans(pyrad[,features_of_interest], na.rm = T)
Q = 3


pyrad$volume_group = gtools::quantcut(pyrad$volume, q=Q, na.rm=TRUE)
pyrad$diameter_group = gtools::quantcut(pyrad$diameter, q=Q, na.rm=TRUE)
pyrad$radITH_group = gtools::quantcut(pyrad$radITH, q=Q, na.rm=TRUE)
```

# Expected correlations
- Negative cor radITH to volume \

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

pyrad = merge(pyrad, oracle,by = "sampleid", all.x = T)
p0 = ggplot(pyrad, aes(x = radITH,  y = volume)) +
  geom_point() + 
  geom_smooth(method = "lm")+
  stat_cor()+
  scale_y_log10()+
  theme_minimal() +
  scale_color_brewer(palette="Set1") 

p1 = ggplot(pyrad, aes(x = radITH,  y = RiskScore)) +
  geom_point() +
  ylab("ORACLE Risk Score") +
  xlab("radITH") +
  geom_smooth(method = 'lm') +
  theme_minimal() +
  stat_cor() +
  scale_fill_brewer(palette="Set1") 
p2 = ggplot(pyrad, aes(x = volume,  y = RiskScore)) +
  geom_point() +
  ylab("ORACLE Risk Score") +
  xlab("Volume") +
  geom_smooth(method = 'lm') +
  theme_minimal() +
  stat_cor() +
  scale_fill_brewer(palette="Set1") 
p3 = ggplot(pyrad, aes(x = diameter,  y = RiskScore)) +
  geom_point() +
  ylab("ORACLE Risk Score") +
  xlab("Diameter") +
  geom_smooth(method = 'lm') +
  theme_minimal() +
  stat_cor() +
  scale_fill_brewer(palette="Set1") 
ggarrange(p0, p1,p2,p3)



pyrad = merge(pyrad, ith2, by.x = "sampleid", by.y = "SampleID", all.x = T)
p1= ggplot(pyrad, aes(x = radITH,  y = Homogeneous)) +
  geom_point() + 
  stat_cor()+
  geom_smooth(method = "lm", se= F)+
  ylab("Homogeneous") +
  theme_minimal() +
  scale_color_brewer(palette="Set1") 
p2= ggplot(pyrad, aes(x = radITH,  y = Heterogeneous)) +
  geom_point() + 
  stat_cor()+
  geom_smooth(method = "lm",se = F)+
  ylab("Heterogeneious") +
  theme_minimal() +
  scale_color_brewer(palette="Set1") 
p3= ggplot(pyrad, aes(x = radITH,  y = FractionTrunk )) +
  geom_point() + 
  geom_smooth(method = "lm", se = F)+
  ylab("FractionTrunk") +
  stat_cor()+
  theme_minimal() +
  scale_color_brewer(palette="Set1") 
ggarrange(p1,p2,p3)

```

# Mutations
Let's group DRIVER mutations by Sanchez Vega def \

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
pyrad$volume_group_med = ifelse(pyrad$volume <= median(pyrad$volume, na.rm = T), "Low", "High")

vega = read.delim2("~/GenomeDK_local/CancerEvolution/phd/Datasets/sanchez-vega-pws_1026.csv", sep = ";")
muts = get(load("~/GenomeDK_local/CancerEvolution/phd/Datasets/TRACERx/WES/patientMutTable_20200622.RData"))
muts$SampleID = sub('LTX','LTX0',substr(muts$SampleID, 0,8))
muts = muts %>% 
  filter(DriverMut == TRUE )

results = data.frame()
samples = c()
for (sample in unique(muts$SampleID)){
  samples = c(samples, sample)
  tmp_muts = muts %>% filter(SampleID == sample)
  have_path_mut = c()
  for (geneGroup in unique(vega$Pathway_pretty)) {
    vega_group = vega %>% filter(Pathway_pretty == geneGroup) 
    if (any(vega_group$Gene %in% tmp_muts$Hugo_Symbol == T)) {
      have_path_mut = c(have_path_mut, T)
    } else {
      have_path_mut = c(have_path_mut, F)
    }
  }
  results = rbind(results, have_path_mut)
}
colnames(results) = as.character(unique(vega$Pathway))
rownames(results) = samples
results$SampleID = rownames(results)


pyrad = merge(pyrad, results, by.y = "SampleID", by.x = "sampleid", all.x = T)

```

# Let's test Sanchez Vega Muts vs radITH groups (q =3)


```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
print("Adeno fisher test results")
tmp = pyrad %>% filter(pathology == "Invasive adenocarcinoma")
for (col in unique(vega$Pathway)){
  if(length(unique(tmp[,col])) >= 2){
    
    test = fisher.test(table(tmp$radITH_group, tmp[,col])) 
    if (test$p.value <= 0.05){
      print(col)
      print(test)
    }
  }
}
print("Squamous fisher test results")
tmp = pyrad %>% filter(pathology == "Squamous cell carcinoma")
for (col in unique(vega$Pathway)){
  if(length(unique(tmp[,col])) >= 2){
    
    test = fisher.test(table(tmp$radITH_group, tmp[,col])) 
    if (test$p.value <= 0.05){
      print(col)
      print(test)
    }
  }
}



```

# SanchezVega vs radITH groups (q = 3) vs pathology vs volume (Median)

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}


for (i in c("High","Low")) {
  for (j in c("Squamous cell carcinoma","Invasive adenocarcinoma" )){

     tmp = pyrad %>% filter(pathology == j,volume_group_med == i) 
     df_res = data.frame()
     for (col in unique(vega$Pathway)){
        if(length(unique(tmp[,col])) >= 2){
          t = fisher.test(table(tmp$radITH_group, tmp[,col])) 
          df_res = rbind(df_res, data.frame(col, t$p.value))
        }
      }
      df_res$adj_p_val = p.adjust(df_res$t.p.value, method = "fdr")
      
      print(ggplot(df_res %>% filter(adj_p_val < 0.06) , aes(x = col, y = -log10(adj_p_val), color =col)) +
        geom_point() +
        ggtitle(paste0(j," ","Volume(median):",i))+
        ylab("-log10(Adj.P)")+
        theme_minimal() + 
        geom_hline(yintercept = -log10(0.05)) +
        theme(axis.text.x = element_text(angle = 90)))
  }
}

```


# Does Volume or diameter predict biology?
- Diameter is not associated at all \

- Volume is associated with HIPPO \

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

print("Adeno fisher test results")
tmp = pyrad %>% filter(pathology == "Invasive adenocarcinoma")
for (col in unique(vega$Pathway)){
  if(length(unique(tmp[,col])) >= 2){
    
    test = fisher.test(table(tmp$diameter_group, tmp[,col])) 
    if (test$p.value <= 0.05){
      print(col)
      print(test)
    }
  }
}
print("Squamous fisher test results")
tmp = pyrad %>% filter(pathology == "Squamous cell carcinoma")
for (col in unique(vega$Pathway)){
  if(length(unique(tmp[,col])) >= 2){
    
    test = fisher.test(table(tmp$volume_group, tmp[,col])) 
    if (test$p.value <= 0.05){
      print(col)
      print(test)
    }
  }
}


```

# How does radITH associate with survival?

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
tmp = pyrad %>% filter(pathology == "Invasive adenocarcinoma")
surv_os <- Surv(as.numeric(as.character(tmp[,'lung_specific_time']))/365, as.numeric(as.character(tmp[,'cens_lung_specific'])))
fit_os <- survfit(survplot::censor(surv_os, 5)~radITH_group, data = tmp)
makeSurvPlot(fit_os, 
             "Adeno", 
             legen_title = "radITH quantiles", 
             ylab = "Lung spec. surv.",legend_coord = c(0.2,0.5),colors = c()) 
tmp = pyrad %>% filter(pathology == "Squamous cell carcinoma")
surv_os <- Surv(as.numeric(as.character(tmp[,'lung_specific_time']))/365, as.numeric(as.character(tmp[,'cens_lung_specific'])))
fit_os <- survfit(survplot::censor(surv_os, 5)~radITH_group, data = tmp)
makeSurvPlot(fit_os, 
             "Squamous", 
             legen_title = "radITH quantiles", 
             ylab = "Lung spec. surv.",legend_coord = c(0.2,0.5),colors = c()) 
tmp = pyrad 
surv_os <- Surv(as.numeric(as.character(tmp[,'lung_specific_time']))/365, as.numeric(as.character(tmp[,'cens_lung_specific'])))
fit_os <- survfit(survplot::censor(surv_os, 5)~radITH_group, data = tmp)
makeSurvPlot(fit_os, 
             "All Data", 
             legen_title = "radITH quantiles", 
             ylab = "Lung spec. surv.",legend_coord = c(0.2,0.5),colors = c()) 


```

# How does volume (diameter) associate to survival?

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
tmp = pyrad %>% filter(pathology == "Invasive adenocarcinoma")
surv_os <- Surv(as.numeric(as.character(tmp[,'lung_specific_time']))/365, as.numeric(as.character(tmp[,'cens_lung_specific'])))
fit_os <- survfit(survplot::censor(surv_os, 5)~volume_group, data = tmp)
makeSurvPlot(fit_os, 
             "Adeno", 
             legen_title = "Vol quantiles", 
             ylab = "Lung spec. surv.",legend_coord = c(0.2,0.5),colors = c()) 
tmp = pyrad %>% filter(pathology == "Squamous cell carcinoma")
surv_os <- Surv(as.numeric(as.character(tmp[,'lung_specific_time']))/365, as.numeric(as.character(tmp[,'cens_lung_specific'])))
fit_os <- survfit(survplot::censor(surv_os, 5)~volume_group, data = tmp)
makeSurvPlot(fit_os, 
             "Squamous", 
             legen_title = "Vol quantiles", 
             ylab = "Lung spec. surv.",legend_coord = c(0.2,0.5),colors = c()) 
tmp = pyrad %>% filter(pathology == "Squamous cell carcinoma")
surv_os <- Surv(as.numeric(as.character(tmp[,'lung_specific_time']))/365, as.numeric(as.character(tmp[,'cens_lung_specific'])))
fit_os <- survfit(survplot::censor(surv_os, 5)~diameter_group, data = tmp)
makeSurvPlot(fit_os, 
             "Squamous", 
             legen_title = "Diam. quantiles", 
             ylab = "Lung spec. surv.",legend_coord = c(0.2,0.5),colors = c()) 

```

# Can we overlap radITH and Volume groups and check survival?
### In order to increase group sizes, all measures will be split by median (Q=2)

```{r echo=FALSE, message=FALSE, warning=FALSE}
pyrad$volume_group_med = ifelse(pyrad$volume <= median(pyrad$volume, na.rm = T), "Low", "High")
pyrad$rad_group_med = ifelse(pyrad$radITH <= median(pyrad$radITH, na.rm = T), "Low", "High")
pyrad$radith_volume_group = paste0("Volume: ",pyrad$volume_group_med, "- radITH: ",pyrad$rad_group_med )

tmp = pyrad %>% filter(pathology == "Invasive adenocarcinoma",
                       volume_group_med == "High")
surv_os <- Surv(as.numeric(as.character(tmp[,'lung_specific_time']))/365, as.numeric(as.character(tmp[,'cens_lung_specific'])))
fit_os <- survfit(survplot::censor(surv_os, 5)~radith_volume_group, data = tmp)
makeSurvPlot(fit_os, 
             "Adeno Large Tumors", 
             legen_title = "Volume-radITH", 
             ylab = "Lung spec. surv.",legend_coord = c(0.2,0.5),colors = c()) 
tmp = pyrad %>% filter(pathology == "Squamous cell carcinoma",
                       volume_group_med == "High")
surv_os <- Surv(as.numeric(as.character(tmp[,'lung_specific_time']))/365, as.numeric(as.character(tmp[,'cens_lung_specific'])))
fit_os <- survfit(survplot::censor(surv_os, 5)~radith_volume_group, data = tmp)
makeSurvPlot(fit_os, 
             "Squamous Large tumors", 
             legen_title = "Volume-radITH", 
             ylab = "Lung spec. surv.",legend_coord = c(0.2,0.5),colors = c())
tmp = pyrad %>% filter(!is.na(rad_group_med), !is.na(volume_group_med))
surv_os <- Surv(as.numeric(as.character(tmp[,'lung_specific_time']))/365, as.numeric(as.character(tmp[,'cens_lung_specific'])))
fit_os <- survfit(survplot::censor(surv_os, 5)~radith_volume_group, data = tmp)
makeSurvPlot(fit_os, 
             "All Data", 
             legen_title = "Volume-radITH", 
             ylab = "Lung spec. surv.",legend_coord = c(0.5,0.5),colors = c())
# Small tumors
tmp = pyrad %>% filter(pathology == "Invasive adenocarcinoma",
                       volume_group_med == "Low")
surv_os <- Surv(as.numeric(as.character(tmp[,'lung_specific_time']))/365, as.numeric(as.character(tmp[,'cens_lung_specific'])))
fit_os <- survfit(survplot::censor(surv_os, 5)~radith_volume_group, data = tmp)
makeSurvPlot(fit_os, 
             "Adeno Small Tumors", 
             legen_title = "Volume-radITH", 
             ylab = "Lung spec. surv.",legend_coord = c(0.2,0.5),colors = c()) 
tmp = pyrad %>% filter(pathology == "Squamous cell carcinoma",
                       volume_group_med == "Low")
surv_os <- Surv(as.numeric(as.character(tmp[,'lung_specific_time']))/365, as.numeric(as.character(tmp[,'cens_lung_specific'])))
fit_os <- survfit(survplot::censor(surv_os, 5)~radith_volume_group, data = tmp)
makeSurvPlot(fit_os, 
             "Squamous Small tumors", 
             legen_title = "Volume-radITH", 
             ylab = "Lung spec. surv.",legend_coord = c(0.2,0.5),colors = c())

```

# Coxph Model
- radITH does not help improve cox ph model \

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
#"Squamous cell carcinoma","Invasive adenocarcinoma"
pyrad$stage = case_when(
  pyrad$NSCLCstage == "IB" ~ "I",
  pyrad$NSCLCstage == "IA" ~ "I",
  pyrad$NSCLCstage == "IIB" ~ "II",
  pyrad$NSCLCstage == "IIA" ~ "II",
  pyrad$NSCLCstage == "IIIA" ~ "III",
  TRUE ~ as.character(pyrad$NSCLCstage)
)

tmp = pyrad %>% filter(pathology %in% c("Squamous cell carcinoma","Invasive adenocarcinoma"),
                       !is.na(stage))

surv_os <- Surv(as.numeric(as.character(tmp[,'lung_specific_time']))/365, as.numeric(as.character(tmp[,'cens_lung_specific'])))



surv_fit = coxph(surv_os ~ radITH +  volume + diameter + RiskScore  +pathology + smoking_status + stage, 
                 data = tmp, robust = T, model = T)
sum_fit = summary(surv_fit)
for_forest = as.data.frame(sum_fit$coefficients)
for_forest = cbind(for_forest, (confint(surv_fit)))
for_forest$param = rownames(for_forest)
#for_forest$`exp(coef)` = (for_forest$coef)
breaks = c(0,seq(-5,5,by = 1))
# and labels
labels = as.character(breaks)
ggplot(data=for_forest,
       aes(x = paste0(param),y = `coef`, ymin =`2.5 %`, ymax = `97.5 %`))+
  geom_pointrange(aes(col=`coef`))+
  geom_hline(yintercept =0, linetype=2) + 
  geom_text(aes(label=paste0(signif.num(`Pr(>|z|)`)),y = 4)) + 
  geom_errorbar(aes(ymin=`2.5 %`,ymax=`97.5 %`,col=`coef`),width=0.5,cex=1)+
  theme(plot.title=element_text(size=16,face="bold"),
        axis.text.x=element_text(face="bold"),
        axis.title=element_text(size=12,face="bold"))+
  
  coord_flip() + 
  theme_pubclean() + 
  xlab("") + 
  ggtitle(paste0("Tracerxs")) + 
  scale_color_gradient(guide = F, low = "#000000", high = "#000000") +
  scale_x_discrete(labels=c("RF_predicted_class4"="STING Group 2")) + 
  scale_y_continuous(limits = c(-5, 5), breaks = breaks, labels = labels,
                     name = "HR")


```

# Hallmarks all samples
- Association (cor) of radITH with hallmarks \

- Hallmarks computed with SS-GSEA \

- P values are adjusted using FDR \


```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
tracerx_exp <- readRDS("~/GenomeDK_local/CancerEvolution/phd/Datasets/TRACERx/RNAseq/log_tpm_summarized_by_sample_exp.rds")
colnames(tracerx_exp) = gsub(substring(colnames(tracerx_exp),3,8),pattern = "LTX", replacement = "LTX0")

########## All samples
hallmarks = hallmarkEnrichment(tracerx_exp,method = "ssgsea") # “gsva”, “ssgsea”, “zscore”, “plage” 
hall_cols = colnames(hallmarks)[1:50]
tmp = merge(pyrad, hallmarks, by.x = "sampleid", by.y = "SampleID")

df_res = data.frame()
for(hal in hall_cols){
  t = cor.test(tmp[,hal], tmp[,"radITH"])
  df_res = rbind(df_res, data.frame(hal,t$estimate, t$p.value))
}
df_res$adj_p_val = p.adjust(df_res$t.p.value, method = "fdr")

ggplot(df_res %>% filter(adj_p_val < 0.05), aes(x = t.estimate, y = -log10(adj_p_val), label = hal)) +
  geom_point() +
  ggtitle("All samples ssGSEA Hallmark correlation to radITH FDR adjusted pval")+
  ylab("-log10(Adj.P)")+xlab("Corr. Coef")+
  geom_text_repel( aes(label=hal), size = 2) + 
  xlim(-1,1) + ylim(0, max(-log10(df_res$adj_p_val) + 0.5)) +
  theme_minimal() + 
  geom_hline(yintercept = -log10(0.05)) +
  theme(axis.text.x = element_text(angle = 90))



```

# Hallmarks Adeno

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

ids =pyrad %>% 
  filter(pathology == "Invasive adenocarcinoma") %>% 
  select(sampleid) %>% 
  unlist()
ids_to_take = ids[ids %in% colnames(tracerx_exp)]


hallmarks = hallmarkEnrichment(tracerx_exp[,ids_to_take],method = "ssgsea") # “gsva”, “ssgsea”, “zscore”, “plage” 
hall_cols = colnames(hallmarks)[1:50]
tmp = merge(pyrad, hallmarks, by.x = "sampleid", by.y = "SampleID")

df_res = data.frame()
for(hal in hall_cols){
  t = cor.test(tmp[,hal], tmp[,"radITH"])
  df_res = rbind(df_res, data.frame(hal,t$estimate, t$p.value))
}
df_res$adj_p_val = p.adjust(df_res$t.p.value, method = "fdr")

ggplot(df_res %>% filter(adj_p_val < 0.06), aes(x = t.estimate, y = -log10(adj_p_val), label = hal)) +
  geom_point() +
  ggtitle("Adeno ssGSEA Hallmark correlation to radITH FDR adjusted pval")+
  ylab("-log10(Adj.P)")+ xlab("Corr. Coef")+
  geom_text_repel( aes(label=hal), size = 2) + 
  xlim(-1,1) + ylim(0, max(-log10(df_res$adj_p_val) + 0.5)) +
  theme_minimal() + 
  geom_hline(yintercept = -log10(0.05)) +
  theme(axis.text.x = element_text(angle = 90))

```

# Hallmarks Squamous

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
ids = pyrad %>% 
  filter(pathology == "Squamous cell carcinoma") %>% 
  select(sampleid) %>% 
  unlist()
ids_to_take = ids[ids %in% colnames(tracerx_exp)]


hallmarks = hallmarkEnrichment(tracerx_exp[,ids_to_take],method = "ssgsea") # “gsva”, “ssgsea”, “zscore”, “plage” 
hall_cols = colnames(hallmarks)[1:50]
tmp = merge(pyrad, hallmarks, by.x = "sampleid", by.y = "SampleID")

df_res = data.frame()
for(hal in hall_cols){
  t = cor.test(tmp[,hal], tmp[,"radITH"])
  df_res = rbind(df_res, data.frame(hal,t$estimate, t$p.value))
}
df_res$adj_p_val = p.adjust(df_res$t.p.value, method = "fdr")

ggplot(df_res %>% filter(adj_p_val < 0.06), aes(x = t.estimate, y = -log10(adj_p_val), label = hal)) +
  geom_point() +
  ggtitle("Squamous ssGSEA Hallmark correlation to radITH FDR adjusted pval")+
  ylab("-log10(Adj.P)")+xlab("Corr. Coef")+
  geom_text_repel( aes(label=hal), size = 2) + 
  xlim(-1,1) + ylim(0, max(-log10(df_res$adj_p_val) + 0.5)) +
  theme_minimal() + 
  geom_hline(yintercept = -log10(0.05)) +
  theme(axis.text.x = element_text(angle = 90))

```

# Hallmark expression-radITH Correlation in Large vs Small tumors (all samples)

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

######### Big Tumors

ids =pyrad %>% 
  filter(volume_group_med == "High") %>% 
  select(sampleid) %>% 
  unlist()
ids_to_take = ids[ids %in% colnames(tracerx_exp)]


hallmarks = hallmarkEnrichment(tracerx_exp[,ids_to_take],method = "ssgsea") # “gsva”, “ssgsea”, “zscore”, “plage” 
hall_cols = colnames(hallmarks)[1:50]
tmp = merge(pyrad, hallmarks, by.x = "sampleid", by.y = "SampleID")

df_res = data.frame()
for(hal in hall_cols){
  t = cor.test(tmp[,hal], tmp[,"radITH"])
  df_res = rbind(df_res, data.frame(hal,t$estimate, t$p.value))
}
df_res$adj_p_val = p.adjust(df_res$t.p.value, method = "fdr")

ggplot(df_res %>% filter(adj_p_val < 0.06), aes(x = t.estimate, y = -log10(adj_p_val), label = hal)) +
  geom_point() +
  ggtitle("Large tumors(median) \nssGSEA Hallmark correlation to radITH FDR adjusted pval")+
  ylab("-log10(Adj.P)")+xlab("Corr. Coef")+
  geom_text_repel( aes(label=hal), size = 2) + 
  xlim(-1,1) + ylim(0, max(-log10(df_res$adj_p_val) + 0.5)) +
  theme_minimal() + 
  geom_hline(yintercept = -log10(0.05)) +
  theme(axis.text.x = element_text(angle = 90))


######### Small Tumors
ids =pyrad %>% 
  filter(volume_group_med == "Low") %>% 
  select(sampleid) %>% 
  unlist()
ids_to_take = ids[ids %in% colnames(tracerx_exp)]


hallmarks = hallmarkEnrichment(tracerx_exp[,ids_to_take],method = "ssgsea") # “gsva”, “ssgsea”, “zscore”, “plage” 
hall_cols = colnames(hallmarks)[1:50]
tmp = merge(pyrad, hallmarks, by.x = "sampleid", by.y = "SampleID")

df_res = data.frame()
for(hal in hall_cols){
  t = cor.test(tmp[,hal], tmp[,"radITH"])
  df_res = rbind(df_res, data.frame(hal,t$estimate, t$p.value))
}
df_res$adj_p_val = p.adjust(df_res$t.p.value, method = "fdr")

ggplot(df_res %>% filter(adj_p_val < 0.06), aes(x = t.estimate, y = -log10(adj_p_val), label = hal)) +
  geom_point() +
  ggtitle("Small tumors (median) \nssGSEA Hallmark correlation to radITH FDR adjusted pval")+
  ylab("-log10(Adj.P)")+xlab("Corr. Coef")+
  geom_text_repel( aes(label=hal), size = 2) + 
  xlim(-1,1) + ylim(0, max(-log10(df_res$adj_p_val) + 0.5)) +
  theme_minimal() + 
  geom_hline(yintercept = -log10(0.05)) +
  theme(axis.text.x = element_text(angle = 90))


```

# Let's split by Size and Pathology and repeat

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
#################### Squmous

for (i in c("High","Low")) {
  for (j in c("Squamous cell carcinoma","Invasive adenocarcinoma" )){
    ids =pyrad %>% 
        filter(volume_group_med == i,
               pathology == j) %>% 
        select(sampleid) %>% 
        unlist()
      ids_to_take = ids[ids %in% colnames(tracerx_exp)]
      
      
      hallmarks = hallmarkEnrichment(tracerx_exp[,ids_to_take],method = "ssgsea") # “gsva”, “ssgsea”, “zscore”, “plage” 
      hall_cols = colnames(hallmarks)[1:50]
      tmp = merge(pyrad, hallmarks, by.x = "sampleid", by.y = "SampleID")
      
      df_res = data.frame()
      for(hal in hall_cols){
        t = cor.test(tmp[,hal], tmp[,"radITH"])
        df_res = rbind(df_res, data.frame(hal,t$estimate, t$p.value))
      }
      df_res$adj_p_val = p.adjust(df_res$t.p.value, method = "fdr")
      
      print(ggplot(df_res %>% filter(adj_p_val < 0.06), aes(x = t.estimate, y = -log10(adj_p_val), label = hal)) +
        geom_point() +
        ggtitle(paste0(j," ","Volume(median): ",i,"\nssGSEA Hallmark correlation to radITH FDR adjusted pval"))+
        ylab("-log10(Adj.P)")+ xlab("Corr coef.")+
        geom_text_repel( aes(label=hal), size = 2) + 
          xlim(-1,1) + ylim(0, max(-log10(df_res$adj_p_val) + 0.5)) +
        theme_minimal() + 
        geom_hline(yintercept = -log10(0.05)) +
        theme(axis.text.x = element_text(angle = 90)))
          
  }
}



```

# Picking genes for Gene Expression Analysis

- Mean and SD value based on entire cohort \

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

mean_sd = data.frame(gene = as.character(rownames(tracerx_exp)),  mean=rowMeans(tracerx_exp),sd=matrixStats::rowSds(as.matrix(tracerx_exp)))
m_sd = mean(mean_sd$sd)
m_m = mean(mean_sd$mean)

mean_sd$show = ""
mean_sd$show = apply(mean_sd, 1, function(x) {
  if(x["sd"] > 0.4006 & x["mean"] > 1.5789){
    x["gene"]
  } else {
    NA
  }
})


ggplot(mean_sd, aes (x = mean, y = sd, label=show) ) +
  geom_point() + 
  geom_hline(yintercept = m_sd) +
  geom_vline(xintercept = m_m) +
  theme_minimal()

genes_for_analysis = mean_sd$show
genes_for_analysis = c(na.omit(genes_for_analysis))
cat("Number of Genes after cutoff: ", length(genes_for_analysis), "\n")
```

# Gene Expression Analysis without volume

- Genes that were picked for analysis were based on mean and SD (entire cohort) \

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

ids = pyrad %>% 
  filter(pathology == "Squamous cell carcinoma") %>% 
  select(sampleid) %>% 
  unlist()
ids_to_take = ids[ids %in% colnames(tracerx_exp)]
tmp_ge = tracerx_exp[genes_for_analysis,ids_to_take]
tmp = pyrad %>% 
  filter(sampleid %in% ids_to_take)

df_res = data.frame()
for(g in genes_for_analysis){
  t = cor.test(unlist(tmp_ge[g,]), tmp[,"radITH"])
  df_res = rbind(df_res, data.frame(g,t$estimate, t$p.value))
}
df_res$adj_p_val = p.adjust(df_res$t.p.value, method = "fdr")

ggplot(df_res %>% filter(adj_p_val < 0.06) , aes(x = t.estimate, y = -log10(adj_p_val), label = g)) +
  geom_point() +
  ggtitle("Squamous all samples ")+
  ylab("-log10(Adj.P)")+ xlab("Corr coef.")+
  theme_minimal() + 
  geom_text_repel( aes(label=g), size = 2) + 
  xlim(-1,1) + ylim(0, max(-log10(df_res$adj_p_val) + 0.5)) + 
  geom_hline(yintercept = -log10(0.05)) +
  theme(axis.text.x = element_text(angle = 90))

ids = pyrad %>% 
  filter(pathology == "Invasive adenocarcinoma") %>% 
  select(sampleid) %>% 
  unlist()
ids_to_take = ids[ids %in% colnames(tracerx_exp)]
tmp_ge = tracerx_exp[genes_for_analysis,ids_to_take]
tmp = pyrad %>% 
  filter(sampleid %in% ids_to_take)

df_res = data.frame()
for(g in genes_for_analysis){
  t = cor.test(unlist(tmp_ge[g,]), tmp[,"radITH"])
  df_res = rbind(df_res, data.frame(g,t$estimate, t$p.value))
}
df_res$adj_p_val = p.adjust(df_res$t.p.value, method = "fdr")

ggplot(df_res %>% filter(adj_p_val < 0.06) , aes(x = t.estimate, y = -log10(adj_p_val), label = g)) +
  geom_point() +
  ggtitle("Adeno all samples")+
  ylab("-log10(Adj.P)" )+ xlab("Corr coef.")+
  geom_text_repel( aes(label=g), size = 2) + 
  xlim(-1,1) + ylim(0, max(-log10(df_res$adj_p_val) + 0.5)) +
  theme_minimal() + 
  geom_hline(yintercept = -log10(0.05)) +
  theme(axis.text.x = element_text(angle = 90))




```

# Gene Expression Analysis by volume group and cancer type (CORRELATION)

- Genes that were picked for analysis were based on mean and SD (entire cohort) \

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}



for (i in c("High","Low")) {
  for (j in c("Squamous cell carcinoma","Invasive adenocarcinoma" )){

      ids = pyrad %>% 
        filter(pathology == j,
               volume_group_med == i) %>% 
        select(sampleid) %>% 
        unlist()
      ids_to_take = ids[ids %in% colnames(tracerx_exp)]
      tmp_ge = tracerx_exp[genes_for_analysis,ids_to_take]
      tmp = pyrad %>% 
        filter(sampleid %in% ids_to_take)
      
      df_res = data.frame()
      for(g in genes_for_analysis){
        t = cor.test(unlist(tmp_ge[g,]), tmp[,"radITH"])
        df_res = rbind(df_res, data.frame(g,t$estimate, t$p.value))
      }
      df_res$adj_p_val = p.adjust(df_res$t.p.value, method = "fdr")
      
      print(ggplot(df_res %>% filter(adj_p_val < 0.06) , aes(x = t.estimate, y = -log10(adj_p_val), label = g)) +
        geom_point() +
        ggtitle(paste0(j," ","Volume(median):",i))+
        geom_text_repel( aes(label=g), size = 2) + 
        ylab("-log10(Adj.P)")+ xlab("Corr coef.")+
          xlim(-1,1) + ylim(0, max(-log10(df_res$adj_p_val) + 0.5)) +
        theme_minimal() + 
        geom_hline(yintercept = -log10(0.05)) +
        theme(axis.text.x = element_text(angle = 90)))
      
  }}
```

# Gene Expression Analysis by volume group and cancer type and radITH group (T-TEST)

```{r eval=FALSE, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}


for (i in as.character(unique(pyrad$radith_volume_group))){
    for (j in c("Squamous cell carcinoma","Invasive adenocarcinoma" )){
  
        ids = pyrad %>% 
          filter(pathology == j,
                 radith_volume_group == i) %>% 
          select(sampleid) %>% 
          unlist()
        ids_to_take = ids[ids %in% colnames(tracerx_exp)]
        tmp_ge = tracerx_exp[genes_for_analysis,ids_to_take]
        tmp = pyrad %>% 
          filter(sampleid %in% ids_to_take)
        
        df_res = data.frame()
        for(g in genes_for_analysis){
          tmp_ge[g,]
          t = cor.test(unlist(tmp_ge[g,]), tmp[,"radITH"])
          df_res = rbind(df_res, data.frame(g,t$estimate, t$p.value))
        }
        df_res$adj_p_val = p.adjust(df_res$t.p.value, method = "fdr")
        
        print(ggplot(df_res %>% filter(adj_p_val < 0.06) , aes(x = t.estimate, y = -log10(adj_p_val), label = g)) +
          geom_point() +
          ggtitle(paste0(j," ","Volume(median):",i))+
          geom_text_repel( aes(label=g), size = 2) + 
          ylab("-log10(Adj.P)")+ xlab("Corr coef.")+
            xlim(-1,1) + ylim(0, max(-log10(df_res$adj_p_val) + 0.5)) +
          theme_minimal() + 
          geom_hline(yintercept = -log10(0.05)) +
          theme(axis.text.x = element_text(angle = 90)))
        
    }
}

```


# Chr Instability and TIL
```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
cin = readRDS("/Users/au589901/GenomeDK_local/CancerEvolution/phd/Analysis/radiomics/computed_files/chr_instability.rds")

cin$sampleid = unlist(lapply(cin$sample_id, function(x){ 
  id = str_split(x, "_")[[1]][2]
  id = paste0(substr(id, 0,3), "0", substr(id, 4,6))
  id
}))

tmp = merge(pyrad, cin, by = "sampleid")

tmp_ = tmp %>% 
        filter(pathology == "Invasive adenocarcinoma") 
df_res = data.frame()
for(g in c("wGII", "Telomeric.AI", "wFLOH", "lst","hrd", "total.til.score.danahaer")){
  t = cor.test(tmp_[,g], tmp_[,"radITH"])
  df_res = rbind(df_res, data.frame(g,t$estimate, t$p.value))
}

print(ggplot(df_res , aes(x = t.estimate, y = -log10(t.p.value), label = g )) +
  geom_point() +
  ggtitle(paste0("Adeno all samples"))+
  ylab("-log10(Adj.P)")+  xlab("Corr coef.")+
  geom_text_repel( aes(label=g), size = 2) + 
    xlim(-1,1) + ylim(0, max(-log10(df_res$t.p.value) + 0.5)) +
  theme_minimal() + 
  geom_hline(yintercept = -log10(0.05)) +
  theme(axis.text.x = element_text(angle = 90)))

tmp_ = tmp %>% 
        filter(pathology == "Squamous cell carcinoma") 
df_res = data.frame()
for(g in c("wGII", "Telomeric.AI", "wFLOH", "lst","hrd", "total.til.score.danahaer")){
  t = cor.test(tmp_[,g], tmp_[,"radITH"])
  df_res = rbind(df_res, data.frame(g,t$estimate, t$p.value))
}

print(ggplot(df_res  , aes(x = t.estimate, y = -log10(t.p.value), label =g )) +
  geom_point() +
  ggtitle(paste0("Squamous all samples"))+
  ylab("-log10(Adj.P)")+  xlab("Corr coef.")+
  geom_text_repel( aes(label=g), size = 2) + 
  xlim(-1,1) + ylim(0, max(-log10(df_res$t.p.value) + 0.5)) +
  theme_minimal() + 
  geom_hline(yintercept = -log10(0.05)) +
  theme(axis.text.x = element_text(angle = 90)))



# Volume vs pathology
for (i in c("High","Low")) {
  for (j in c("Squamous cell carcinoma","Invasive adenocarcinoma" )){

      tmp_ = tmp %>% 
        filter(pathology == j,
               volume_group_med == i) 
      
      df_res = data.frame()
      for(g in c("wGII", "Telomeric.AI", "wFLOH", "lst","hrd", "total.til.score.danahaer")){
        t = cor.test(tmp_[,g], tmp_[,"radITH"])
        df_res = rbind(df_res, data.frame(g,t$estimate, t$p.value))
      }

      
      print(ggplot(df_res , aes(x = t.estimate, y = -log10(t.p.value), label = g )) +
        geom_point() +
        ggtitle(paste0(j," ","Volume(median):",i))+
        geom_text_repel( aes(label=g), size = 2) + 
        ylab("-log10(Adj.P)")+
          xlim(-1,1) + ylim(0, max(-log10(df_res$t.p.value) + 0.5)) +
        theme_minimal() + xlab("Corr coef.")+
        geom_hline(yintercept = -log10(0.05)) +
        theme(axis.text.x = element_text(angle = 90)))
  }
}

```

# Can we use pyrad features to predict biological features?

- As it does not make sense to split small amount of observations by pathology I will include pathology as parameter in the model \

- IMPORTANT! Params in model: chosen pyRad features, pathology, radITH and volume \

- The results represent Logistic regression with 3-fold (5 times repeated) CV using R-Caret package \

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
library(caret)
library(visreg)  ## For visualizing regression models
library(plotROC) ## For constructing ROC curves
library(mgcv)    ## For fitting GAM models
library(glmnet)  ## For fitting regularized models

sample_split = 0.75

vega_muts = c(as.character(unique(vega$Pathway)))
tmp = pyrad
tmp$pathology = as.factor(tmp$pathology)
fit.control <- trainControl(method = "repeatedcv", 
                            number = 3, repeats = 5, 
                            classProbs = TRUE)
indx = sample(nrow(tmp),size= sample_split * nrow(tmp))
train_tmp = tmp[indx,]
test_tmp = tmp[-indx,]


for (par in c(vega_muts, unique(cin_measures), "total.til.score.danahaer")){
    print(par)
    response =  par
    col_to_take = 2
    if (response %in% vega_muts){
       col_to_take = 2
       test_tmp_ = train_tmp
       train_tmp$response = as.factor(train_tmp[,response])
       test_tmp_$response = as.factor(test_tmp_[,response])
       tmp_ = train_tmp[complete.cases(train_tmp[,response]),]
       tmp_[,"response"] = make.names(tmp_[,"response"])
       test_tmp_$response = as.factor(test_tmp_[,"response"])
    } else if (response %in% c(cin_measures, "total.til.score.danahaer")) {
        col_to_take = 1
        tmp_ = merge(train_tmp, cin, by = "sampleid")
        test_tmp_ = merge(test_tmp, cin, by = "sampleid")
        tmp_$hrd_score = tmp_$lst + tmp_$Telomeric.AI + tmp_$hrd
        test_tmp_$hrd_score = test_tmp_$lst + test_tmp_$Telomeric.AI + test_tmp_$hrd
        if (response == "hrd_score"){
          tmp_$response = as.factor(ifelse(tmp_[,response] > 42, "High", "Low"))
          test_tmp_$response = as.factor(ifelse(test_tmp_[,response] > 42, "High", "Low"))
        } else {
          tmp_$response = as.factor(ifelse(tmp_[,response] > median(tmp_[,response]), "High", "Low"))
          test_tmp_$response = as.factor(ifelse(test_tmp_[,response] > median(test_tmp_[,response]), "High", "Low"))
        }
        
    } else {
       tmp_ = train_tmp
       test_tmp_ = train_tmp
       tmp_$response = as.factor(ifelse(tmp_[,response] > median(tmp_[,response]), "High", "Low"))
       test_tmp_$response = as.factor(ifelse(test_tmp_[,response] > median(test_tmp_[,response]), "High", "Low"))
    }
       
    
    fit <- train(as.formula(paste("response~pathology+radITH+volume+", paste(features_of_interest, collapse="+"))), method = "glm",  family = "binomial", trControl = fit.control, data = tmp_)
       
    df <- data.frame(response_var = test_tmp_$response, Prob = predict(fit, test_tmp_, type = "prob")[,col_to_take])
    p = ggplot(df, aes(d = response_var, m = Prob)) + 
      geom_roc() +
      theme_minimal()+
      geom_abline(intercept =0 , slope = 1) + 
      theme(plot.title = element_text(size=8))
    auc = calc_auc(p)[3][[1]]
    assign(p + ggtitle(paste0("Binary ",response," AUC: ",round(auc,4))), x = par)
}

ggarrange(rtk_kras,nrf2, pi3k, tgfb,p53,cell_cycle, wnt, myc, hippo, notch)
ggarrange(wGII, hrd, lst, Telomeric.AI, wFLOH, hrd_score, total.til.score.danahaer)

```

# Can we use radITH and pyRad Features for the same results?

- As it does not make sense to split small amount of observations by pathology I will include pathology as parameter in the model \

- IMPORTANT! Params in model: chosen pyRad features, pathology, radITH \

- The results represent Logistic regression with 3-fold (5 time repeated) CV using R-Caret package \

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

vega_muts = c(as.character(unique(vega$Pathway)))
tmp = pyrad
tmp$pathology = as.factor(tmp$pathology)
fit.control <- trainControl(method = "repeatedcv", 
                            number = 3, repeats = 5, 
                            classProbs = TRUE)
indx = sample(nrow(tmp),size= sample_split * nrow(tmp))
train_tmp = tmp[indx,]
test_tmp = tmp[-indx,]


for (par in c(vega_muts, unique(cin_measures), "total.til.score.danahaer")){
    print(par)
    response =  par
    col_to_take = 2
    if (response %in% vega_muts){
       col_to_take = 2
       test_tmp_ = train_tmp
       train_tmp$response = as.factor(train_tmp[,response])
       test_tmp_$response = as.factor(test_tmp_[,response])
       tmp_ = train_tmp[complete.cases(train_tmp[,response]),]
       tmp_[,"response"] = make.names(tmp_[,"response"])
       test_tmp_$response = as.factor(test_tmp_[,"response"])
    } else if (response %in% c(cin_measures, "total.til.score.danahaer")) {
        col_to_take = 2
        tmp_ = merge(train_tmp, cin, by = "sampleid")
        test_tmp_ = merge(test_tmp, cin, by = "sampleid")
        tmp_$hrd_score = tmp_$lst + tmp_$Telomeric.AI + tmp_$hrd
        test_tmp_$hrd_score = test_tmp_$lst + test_tmp_$Telomeric.AI + test_tmp_$hrd
        if (response == "hrd_score"){
          tmp_$response = as.factor(ifelse(tmp_[,response] > 42, "High", "Low"))
          test_tmp_$response = as.factor(ifelse(test_tmp_[,response] > 42, "High", "Low"))
        } else {
          tmp_$response = as.factor(ifelse(tmp_[,response] > median(tmp_[,response]), "High", "Low"))
          test_tmp_$response = as.factor(ifelse(test_tmp_[,response] > median(test_tmp_[,response]), "High", "Low"))
        }
        
    } else {
       tmp_ = train_tmp
       test_tmp_ = train_tmp
       tmp_$response = as.factor(ifelse(tmp_[,response] > median(tmp_[,response]), "High", "Low"))
       test_tmp_$response = as.factor(ifelse(test_tmp_[,response] > median(test_tmp_[,response]), "High", "Low"))
    }
       
    
    fit <- train(as.formula(paste("response~pathology+radITH+", paste(features_of_interest, collapse="+"))), method = "glm",  family = "binomial", trControl = fit.control, data = tmp_)
       
    df <- data.frame(response_var = test_tmp_$response, Prob = predict(fit, test_tmp_, type = "prob")[,col_to_take])
    p = ggplot(df, aes(d = response_var, m = Prob)) + 
      geom_roc() +
      theme_minimal()+
      geom_abline(intercept =0 , slope = 1) + 
      theme(plot.title = element_text(size=8))
    auc = calc_auc(p)[3][[1]]
    assign(p + ggtitle(paste0("Binary ",response," AUC: ",round(auc,4))), x = par)
}

ggarrange(rtk_kras,nrf2, pi3k, tgfb,p53,cell_cycle, wnt, myc, hippo, notch)
ggarrange(wGII, hrd, lst, Telomeric.AI, wFLOH, hrd_score, total.til.score.danahaer)

```


# Can we use only volume and Patholgy for the same results?

- As it does not make sense to split small amount of observations by pathology I will include pathology as parameter in the model \

- IMPORTANT! Params in model: pathology, volume \

- The results represent Logistic regression with 3-fold (5 time repeated) CV using R-Caret package \

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}


vega_muts = c(as.character(unique(vega$Pathway)))
tmp = pyrad
tmp$pathology = as.factor(tmp$pathology)
fit.control <- trainControl(method = "repeatedcv", 
                            number = 3, repeats = 5, 
                            classProbs = TRUE)
indx = sample(nrow(tmp),size= sample_split * nrow(tmp))
train_tmp = tmp[indx,]
test_tmp = tmp[-indx,]


for (par in c(vega_muts, unique(cin_measures), "total.til.score.danahaer")){
    print(par)
    response =  par
    col_to_take = 2
    if (response %in% vega_muts){
       col_to_take = 2
       test_tmp_ = train_tmp
       train_tmp$response = as.factor(train_tmp[,response])
       test_tmp_$response = as.factor(test_tmp_[,response])
       tmp_ = train_tmp[complete.cases(train_tmp[,response]),]
       tmp_[,"response"] = make.names(tmp_[,"response"])
       test_tmp_$response = as.factor(test_tmp_[,"response"])
    } else if (response %in% c(cin_measures, "total.til.score.danahaer")) {
        col_to_take = 2
        tmp_ = merge(train_tmp, cin, by = "sampleid")
        test_tmp_ = merge(test_tmp, cin, by = "sampleid")
        tmp_$hrd_score = tmp_$lst + tmp_$Telomeric.AI + tmp_$hrd
        test_tmp_$hrd_score = test_tmp_$lst + test_tmp_$Telomeric.AI + test_tmp_$hrd
        if (response == "hrd_score"){
          tmp_$response = as.factor(ifelse(tmp_[,response] > 42, "High", "Low"))
          test_tmp_$response = as.factor(ifelse(test_tmp_[,response] > 42, "High", "Low"))
        } else {
          tmp_$response = as.factor(ifelse(tmp_[,response] > median(tmp_[,response]), "High", "Low"))
          test_tmp_$response = as.factor(ifelse(test_tmp_[,response] > median(test_tmp_[,response]), "High", "Low"))
        }
        
    } else {
       tmp_ = train_tmp
       test_tmp_ = train_tmp
       tmp_$response = as.factor(ifelse(tmp_[,response] > median(tmp_[,response]), "High", "Low"))
       test_tmp_$response = as.factor(ifelse(test_tmp_[,response] > median(test_tmp_[,response]), "High", "Low"))
    }
       
    
    fit <- train(as.formula(paste("response~pathology+volume")), method = "glm",  family = "binomial", trControl = fit.control, data = tmp_)
       
    df <- data.frame(response_var = test_tmp_$response, Prob = predict(fit, test_tmp_, type = "prob")[,col_to_take])
    p = ggplot(df, aes(d = response_var, m = Prob)) + 
      geom_roc() +
      theme_minimal()+
      geom_abline(intercept =0 , slope = 1) + 
      theme(plot.title = element_text(size=8))
    auc = calc_auc(p)[3][[1]]
    assign(p + ggtitle(paste0("Binary ",response," AUC: ",round(auc,4))), x = par)
}

ggarrange(rtk_kras,nrf2, pi3k, tgfb,p53,cell_cycle, wnt, myc, hippo, notch)
ggarrange(wGII, hrd, lst, Telomeric.AI, wFLOH, hrd_score, total.til.score.danahaer)


```


# Can we use only radITH and Patholgy for the same results?

- As it does not make sense to split small amount of observations by pathology I will include pathology as parameter in the model \

- IMPORTANT! Params in model: pathology, radITH \

- The results represent Logistic regression with 3-fold (5 time repeated) CV using R-Caret package \

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}


vega_muts = c(as.character(unique(vega$Pathway)))
tmp = pyrad
tmp$pathology = as.factor(tmp$pathology)
fit.control <- trainControl(method = "repeatedcv", 
                            number = 3, repeats = 5, 
                            classProbs = TRUE)
indx = sample(nrow(tmp),size= sample_split * nrow(tmp))
train_tmp = tmp[indx,]
test_tmp = tmp[-indx,]


for (par in c(vega_muts, unique(cin_measures), "total.til.score.danahaer")){
    print(par)
    response =  par
    col_to_take = 2
    if (response %in% vega_muts){
       col_to_take = 2
       test_tmp_ = train_tmp
       train_tmp$response = as.factor(train_tmp[,response])
       test_tmp_$response = as.factor(test_tmp_[,response])
       tmp_ = train_tmp[complete.cases(train_tmp[,response]),]
       tmp_[,"response"] = make.names(tmp_[,"response"])
       test_tmp_$response = as.factor(test_tmp_[,"response"])
    } else if (response %in% c(cin_measures, "total.til.score.danahaer")) {
        col_to_take = 2
        tmp_ = merge(train_tmp, cin, by = "sampleid")
        test_tmp_ = merge(test_tmp, cin, by = "sampleid")
        tmp_$hrd_score = tmp_$lst + tmp_$Telomeric.AI + tmp_$hrd
        test_tmp_$hrd_score = test_tmp_$lst + test_tmp_$Telomeric.AI + test_tmp_$hrd
        if (response == "hrd_score"){
          tmp_$response = as.factor(ifelse(tmp_[,response] > 42, "High", "Low"))
          test_tmp_$response = as.factor(ifelse(test_tmp_[,response] > 42, "High", "Low"))
        } else {
          tmp_$response = as.factor(ifelse(tmp_[,response] > median(tmp_[,response]), "High", "Low"))
          test_tmp_$response = as.factor(ifelse(test_tmp_[,response] > median(test_tmp_[,response]), "High", "Low"))
        }
    } else {
       tmp_ = train_tmp
       test_tmp_ = train_tmp
       tmp_$response = as.factor(ifelse(tmp_[,response] > median(tmp_[,response]), "High", "Low"))
       test_tmp_$response = as.factor(ifelse(test_tmp_[,response] > median(test_tmp_[,response]), "High", "Low"))
    }
       
    
    fit <- train(as.formula(paste("response~pathology+radITH")), method = "glm",  family = "binomial", trControl = fit.control, data = tmp_)
       
    df <- data.frame(response_var = test_tmp_$response, Prob = predict(fit, test_tmp_, type = "prob")[,col_to_take])
    p = ggplot(df, aes(d = response_var, m = Prob)) + 
      geom_roc() +
      theme_minimal()+
      geom_abline(intercept =0 , slope = 1) + 
      theme(plot.title = element_text(size=8))
    auc = calc_auc(p)[3][[1]]
    assign(p + ggtitle(paste0("Binary ",response," AUC: ",round(auc,4))), x = par)
}

ggarrange(rtk_kras,nrf2, pi3k, tgfb,p53,cell_cycle, wnt, myc, hippo, notch)
ggarrange(wGII, hrd, lst, Telomeric.AI, wFLOH, hrd_score, total.til.score.danahaer)

```



# Final complicated model with interactio between volume and radITH

- As it does not make sense to split small amount of observations by pathology I will include pathology as parameter in the model \

- IMPORTANT! Params in model: chosen pyRad features, pathology, radITH and volume \

- The results represent Logistic regression with 3-fold (5 time repeated) CV using R-Caret package \

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

vega_muts = c(as.character(unique(vega$Pathway)))
tmp = pyrad
tmp$pathology = as.factor(tmp$pathology)
fit.control <- trainControl(method = "repeatedcv", 
                            number = 3, repeats = 5, 
                            classProbs = TRUE)
indx = sample(nrow(tmp),size= sample_split * nrow(tmp))
train_tmp = tmp[indx,]
test_tmp = tmp[-indx,]


for (par in c(vega_muts, cin_measures, "total.til.score.danahaer")){
    print(par)
    response =  par
    col_to_take = 2
    if (response %in% vega_muts){
       col_to_take = 2
       test_tmp_ = train_tmp
       train_tmp$response = as.factor(train_tmp[,response])
       test_tmp_$response = as.factor(test_tmp_[,response])
       tmp_ = train_tmp[complete.cases(train_tmp[,response]),]
       tmp_[,"response"] = make.names(tmp_[,"response"])
       test_tmp_$response = as.factor(test_tmp_[,"response"])
    } else if (response %in% c(cin_measures, "total.til.score.danahaer")) {
        col_to_take = 2
        tmp_ = merge(train_tmp, cin, by = "sampleid")
        test_tmp_ = merge(test_tmp, cin, by = "sampleid")
        tmp_$hrd_score = tmp_$lst + tmp_$Telomeric.AI + tmp_$hrd
        test_tmp_$hrd_score = test_tmp_$lst + test_tmp_$Telomeric.AI + test_tmp_$hrd
        tmp_$response = as.factor(ifelse(tmp_[,response] > median(tmp_[,response]), "High", "Low"))
        test_tmp_$response = as.factor(ifelse(test_tmp_[,response] > median(test_tmp_[,response]), "High", "Low"))
    } else {
       tmp_ = train_tmp
       test_tmp_ = train_tmp
       tmp_$response = as.factor(ifelse(tmp_[,response] > median(tmp_[,response]), "High", "Low"))
       test_tmp_$response = as.factor(ifelse(test_tmp_[,response] > median(test_tmp_[,response]), "High", "Low"))
    }
       
    
    fit <- train(as.formula(paste("response~pathology+radITH+volume")), method = "glm",  family = "binomial", trControl = fit.control, data = tmp_)
       
    df <- data.frame(response_var = test_tmp_$response, Prob = predict(fit, test_tmp_, type = "prob")[,col_to_take])
    p = ggplot(df, aes(d = response_var, m = Prob)) + 
      geom_roc() +
      theme_minimal()+
      geom_abline(intercept =0 , slope = 1) + 
      theme(plot.title = element_text(size=8))
    auc = calc_auc(p)[3][[1]]
    assign(p + ggtitle(paste0("Binary ",response," AUC: ",round(auc,4))), x = par)
}

ggarrange(rtk_kras,nrf2, pi3k, tgfb,p53,cell_cycle, wnt, myc, hippo, notch)
ggarrange(wGII, hrd, lst, Telomeric.AI, wFLOH, hrd_score, total.til.score.danahaer)


```

# Comparison to RNA Computed ITH

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
bioITHgenes = read.delim2("/Users/au589901/GenomeDK_local/CancerEvolution/phd/Analysis/radiomics/computed_files/ith_comparison_full.csv", sep = ",")
bioITH = read.delim2("/Users/au589901/GenomeDK_local/CancerEvolution/phd/Analysis/radiomics/computed_files/patient_rna_ith_scores.csv", sep = ",")
bioITH$sampleid = paste0(substr(bioITH$PatientID,0,3), "0",substr(bioITH$PatientID,4, 8))
bioITH$rna_ith = as.numeric(bioITH$rna_ith)
bioITH$SCNA_ith = as.numeric(bioITH$SCNA_ith)
bioITH$SNV_ith = as.numeric(bioITH$SNV_ith)

tmp = merge(pyrad, bioITH, by = "sampleid")

p1 = ggplot(tmp, aes(x = SCNA_ith, y = radITH, color = pathology)) +
  geom_point() + 
  theme_minimal()+
  geom_smooth(method = "lm", se = F) +
  stat_cor()

p2 = ggplot(tmp, aes(x = SNV_ith, y = radITH, color = pathology)) +
  geom_point() + 
  theme_minimal()+
  geom_smooth(method = "lm", se = F) +
  stat_cor()

p3 = ggplot(tmp, aes(x = rna_ith, y = radITH, color = pathology)) +
  geom_point() + 
  theme_minimal()+
  geom_smooth(method = "lm", se = F) +
  stat_cor()

ggarrange(p1,p2,p3)

```





